package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/suite"
)

// NginxTestSuite tests the nginx proxy functionality
type NginxTestSuite struct {
	suite.Suite
	tempDir string
}

func (suite *NginxTestSuite) SetupTest() {
	// Create temp directory for test files
	tempDir, err := os.MkdirTemp("", "fleet-nginx-test-*")
	suite.Require().NoError(err)
	suite.tempDir = tempDir
}

func (suite *NginxTestSuite) TearDownTest() {
	// Clean up temp directory
	os.RemoveAll(suite.tempDir)
}

// Test shouldAddNginxProxy with various configurations
func (suite *NginxTestSuite) TestShouldAddNginxProxy_NoDomainNoPort() {
	// Given: Config with services that have no domain or port
	config := &Config{
		Project: "test-project",
		Services: []Service{
			{
				Name:  "service1",
				Image: "nginx:latest",
			},
			{
				Name:  "service2",
				Image: "redis:latest",
			},
		},
	}

	// When: checking if nginx proxy should be added
	result := shouldAddNginxProxy(config)

	// Then: it should return false
	suite.False(result, "Should not add nginx proxy when no services have domain or port")
}

func (suite *NginxTestSuite) TestShouldAddNginxProxy_WithExplicitDomain() {
	// Given: Config with at least one service having an explicit domain
	config := &Config{
		Project: "test-project",
		Services: []Service{
			{
				Name:   "web",
				Image:  "nginx:latest",
				Domain: "myapp.test",
			},
			{
				Name:  "db",
				Image: "postgres:latest",
			},
		},
	}

	// When: checking if nginx proxy should be added
	result := shouldAddNginxProxy(config)

	// Then: it should return true
	suite.True(result, "Should add nginx proxy when a service has an explicit domain")
}

func (suite *NginxTestSuite) TestShouldAddNginxProxy_WithPort() {
	// Given: Config with at least one service having a port
	config := &Config{
		Project: "test-project",
		Services: []Service{
			{
				Name:  "api",
				Image: "node:latest",
				Port:  3000,
			},
		},
	}

	// When: checking if nginx proxy should be added
	result := shouldAddNginxProxy(config)

	// Then: it should return true
	suite.True(result, "Should add nginx proxy when a service has a port")
}

// Test getDomainForService with explicit and auto-generated domains
func (suite *NginxTestSuite) TestGetDomainForService_ExplicitDomain() {
	// Given: Service with explicit domain
	service := &Service{
		Name:   "web",
		Domain: "custom.test",
		Port:   8080,
	}

	// When: getting domain for service
	domain := getDomainForService(service)

	// Then: it should return the explicit domain
	suite.Equal("custom.test", domain, "Should return explicit domain when set")
}

func (suite *NginxTestSuite) TestGetDomainForService_AutoGenerated() {
	// Given: Service with port but no explicit domain
	service := &Service{
		Name: "api-server",
		Port: 3000,
	}

	// When: getting domain for service
	domain := getDomainForService(service)

	// Then: it should auto-generate domain as {name}.test
	suite.Equal("api-server.test", domain, "Should auto-generate domain as {name}.test")
}

func (suite *NginxTestSuite) TestGetDomainForService_NoPortNoDomain() {
	// Given: Service with neither port nor domain
	service := &Service{
		Name:  "worker",
		Image: "worker:latest",
	}

	// When: getting domain for service
	domain := getDomainForService(service)

	// Then: it should return empty string
	suite.Empty(domain, "Should return empty string when no port or domain")
}

func (suite *NginxTestSuite) TestGetDomainForService_ExplicitDomainNoPort() {
	// Given: Service with explicit domain but no port
	service := &Service{
		Name:   "frontend",
		Domain: "app.test",
	}

	// When: getting domain for service
	domain := getDomainForService(service)

	// Then: it should still return the explicit domain
	suite.Equal("app.test", domain, "Should return explicit domain even without port")
}

// Test generateNginxConfig creates valid nginx configuration
func (suite *NginxTestSuite) TestGenerateNginxConfig_ValidConfig() {
	// Given: Config with multiple services
	config := &Config{
		Project: "test-app",
		Services: []Service{
			{
				Name:   "web",
				Domain: "web.test",
				Port:   8080,
			},
			{
				Name: "api",
				Port: 3000,
			},
			{
				Name:  "db",
				Image: "postgres:latest",
			},
		},
	}

	// When: generating nginx config
	nginxConf, err := generateNginxConfig(config)

	// Then: it should generate valid config without error
	suite.NoError(err, "Should generate nginx config without error")
	suite.NotEmpty(nginxConf, "Generated config should not be empty")

	// Verify config contains expected elements
	suite.Contains(nginxConf, "upstream web_backend", "Should contain upstream for web service")
	suite.Contains(nginxConf, "server web:8080", "Should contain correct upstream server for web")
	suite.Contains(nginxConf, "server_name web.test", "Should contain server_name for web.test")

	suite.Contains(nginxConf, "upstream api_backend", "Should contain upstream for api service")
	suite.Contains(nginxConf, "server api:3000", "Should contain correct upstream server for api")
	suite.Contains(nginxConf, "server_name api.test", "Should contain auto-generated domain for api")

	// Should not contain db service as it has no domain/port
	suite.NotContains(nginxConf, "upstream db_backend", "Should not contain upstream for db service")
}

func (suite *NginxTestSuite) TestGenerateNginxConfig_WithPortsArray() {
	// Given: Service with ports array instead of single port
	// NOTE: Services need either a Port field or Domain field to be included in nginx config
	config := &Config{
		Project: "test-app",
		Services: []Service{
			{
				Name:   "web",
				Domain: "web.test", // Need explicit domain since Port field is not set
				Ports:  []string{"8080:80", "8443:443"},
			},
		},
	}

	// When: generating nginx config
	nginxConf, err := generateNginxConfig(config)

	// Then: it should extract port from the ports array
	suite.NoError(err, "Should handle ports array")
	suite.Contains(nginxConf, "server web:80", "Should extract container port from ports mapping")
}

func (suite *NginxTestSuite) TestGenerateNginxConfig_EmptyServices() {
	// Given: Config with no services
	config := &Config{
		Project:  "test-app",
		Services: []Service{},
	}

	// When: generating nginx config
	nginxConf, err := generateNginxConfig(config)

	// Then: it should generate base config without services
	suite.NoError(err, "Should handle empty services")
	suite.Contains(nginxConf, "worker_processes", "Should contain base nginx config")
	suite.NotContains(nginxConf, "upstream", "Should not contain any upstreams")
}

// Test addNginxProxyToCompose adds the service correctly
func (suite *NginxTestSuite) TestAddNginxProxyToCompose_AddsService() {
	// Given: Docker compose and config that needs nginx
	compose := &DockerCompose{
		Version: "3.8",
		Services: map[string]DockerService{
			"web": {
				Image: "nginx:latest",
				Ports: []string{"8080:80"},
			},
		},
		Networks: map[string]DockerNetwork{
			"fleet-network": {},
		},
	}

	config := &Config{
		Project: "test-app",
		Services: []Service{
			{
				Name:   "web",
				Domain: "web.test",
				Port:   8080,
			},
		},
	}

	// Change to temp directory for .fleet folder creation
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(suite.tempDir)

	// When: adding nginx proxy to compose
	addNginxProxyToCompose(compose, config)

	// Then: nginx-proxy service should be added
	nginxService, exists := compose.Services["nginx-proxy"]
	suite.True(exists, "nginx-proxy service should be added")
	suite.Equal("nginx:alpine", nginxService.Image, "Should use nginx:alpine image")
	suite.Contains(nginxService.Ports, "80:80", "Should expose port 80 - only nginx should bind to 80")
	
	// Check that volume mount uses absolute path and contains nginx.conf
	suite.Len(nginxService.Volumes, 1, "Should have one volume mount")
	suite.Contains(nginxService.Volumes[0], "nginx.conf", "Should mount nginx config")
	suite.Contains(nginxService.Volumes[0], ":/etc/nginx/nginx.conf:ro", "Should mount to /etc/nginx/nginx.conf as read-only")
	suite.Contains(nginxService.Volumes[0], suite.tempDir, "Should use absolute path from temp dir")
	
	suite.Contains(nginxService.Networks, "fleet-network", "Should be on fleet-network")
	suite.Equal("unless-stopped", nginxService.Restart, "Should have restart policy")
	suite.Contains(nginxService.DependsOn, "web", "Should depend on web service")

	// Verify health check
	suite.NotNil(nginxService.HealthCheck, "Should have health check")
	suite.Contains(nginxService.HealthCheck.Test, "wget", "Health check should use wget")
	
	// Verify nginx.conf file was actually created
	nginxConfigPath := filepath.Join(suite.tempDir, ".fleet", "nginx.conf")
	_, err := os.Stat(nginxConfigPath)
	suite.NoError(err, "nginx.conf should be created before docker service")
	
	// Verify file permissions
	info, _ := os.Stat(nginxConfigPath)
	suite.Equal(os.FileMode(0644), info.Mode().Perm(), "nginx.conf should have 0644 permissions")
}

func (suite *NginxTestSuite) TestAddNginxProxyToCompose_NoNginxNeeded() {
	// Given: Config that doesn't need nginx
	compose := &DockerCompose{
		Version:  "3.8",
		Services: map[string]DockerService{},
	}

	config := &Config{
		Project: "test-app",
		Services: []Service{
			{
				Name:  "worker",
				Image: "worker:latest",
			},
		},
	}

	// When: adding nginx proxy to compose
	addNginxProxyToCompose(compose, config)

	// Then: nginx-proxy service should NOT be added
	_, exists := compose.Services["nginx-proxy"]
	suite.False(exists, "nginx-proxy service should not be added when not needed")
}

func (suite *NginxTestSuite) TestAddNginxProxyToCompose_FileCreationOrder() {
	// Given: Docker compose and config that needs nginx
	compose := &DockerCompose{
		Version:  "3.8",
		Services: map[string]DockerService{},
		Networks: map[string]DockerNetwork{
			"fleet-network": {},
		},
	}

	config := &Config{
		Project: "test-app",
		Services: []Service{
			{
				Name:   "api",
				Domain: "api.test",
				Port:   3000,
			},
		},
	}

	// Change to temp directory for .fleet folder creation
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(suite.tempDir)

	// When: adding nginx proxy to compose
	addNginxProxyToCompose(compose, config)

	// Then: verify the file was created before being referenced
	nginxService, exists := compose.Services["nginx-proxy"]
	suite.True(exists, "nginx-proxy service should be added")
	
	// The volume mount should use absolute path
	suite.Len(nginxService.Volumes, 1, "Should have exactly one volume mount")
	volumeMount := nginxService.Volumes[0]
	
	// Extract the source path from the volume mount (format: /abs/path/nginx.conf:/etc/nginx/nginx.conf:ro)
	parts := strings.Split(volumeMount, ":")
	suite.Len(parts, 3, "Volume mount should have source:dest:mode format")
	
	sourcePath := parts[0]
	suite.True(filepath.IsAbs(sourcePath), "Source path should be absolute")
	suite.Contains(sourcePath, "nginx.conf", "Source path should reference nginx.conf")
	
	// Verify the file exists at the source path
	info, err := os.Stat(sourcePath)
	suite.NoError(err, "nginx.conf file should exist at the source path")
	suite.False(info.IsDir(), "nginx.conf should be a file, not a directory")
	suite.Equal(os.FileMode(0644), info.Mode().Perm(), "File should have correct permissions")
}

// Test getDomainMappings returns correct mappings
func (suite *NginxTestSuite) TestGetDomainMappings_SingleService() {
	// Given: Config with one service with domain
	config := &Config{
		Services: []Service{
			{
				Name:   "web",
				Domain: "app.test",
				Port:   8080,
			},
		},
	}

	// When: getting domain mappings
	mappings := getDomainMappings(config)

	// Then: it should return correct mapping
	suite.Len(mappings, 1, "Should have one mapping")
	suite.Equal("127.0.0.1", mappings["app.test"], "Domain should map to localhost")
}

func (suite *NginxTestSuite) TestGetDomainMappings_MultipleServices() {
	// Given: Config with multiple services
	config := &Config{
		Services: []Service{
			{
				Name:   "web",
				Domain: "web.test",
				Port:   8080,
			},
			{
				Name: "api",
				Port: 3000,
			},
			{
				Name:  "db",
				Image: "postgres",
			},
		},
	}

	// When: getting domain mappings
	mappings := getDomainMappings(config)

	// Then: it should return mappings for services with domains
	suite.Len(mappings, 2, "Should have two mappings")
	suite.Equal("127.0.0.1", mappings["web.test"], "web.test should map to localhost")
	suite.Equal("127.0.0.1", mappings["api.test"], "api.test should map to localhost")
}

func (suite *NginxTestSuite) TestGetDomainMappings_Empty() {
	// Given: Config with no services needing domains
	config := &Config{
		Services: []Service{
			{
				Name:  "worker",
				Image: "worker:latest",
			},
		},
	}

	// When: getting domain mappings
	mappings := getDomainMappings(config)

	// Then: it should return empty map
	suite.Empty(mappings, "Should return empty map when no domains")
}

// Test hosts file update logic using temp files
func (suite *NginxTestSuite) TestUpdateHostsFileWithDomains_AddNewEntries() {
	// Given: Existing hosts file and config with domains
	hostsFile := filepath.Join(suite.tempDir, "hosts")
	existingContent := `127.0.0.1 localhost
::1 localhost

# Some existing entries
192.168.1.1 router.local`

	err := os.WriteFile(hostsFile, []byte(existingContent), 0644)
	suite.Require().NoError(err)

	// Mock getHostsFilePath to return our test file
	originalGetHostsFilePath := getHostsFilePath
	getHostsFilePath = func() string { return hostsFile }
	defer func() { getHostsFilePath = originalGetHostsFilePath }()

	config := &Config{
		Services: []Service{
			{
				Name:   "web",
				Domain: "web.test",
				Port:   8080,
			},
			{
				Name: "api",
				Port: 3000,
			},
		},
	}

	// When: updating hosts file
	err = updateHostsFileWithDomains(config)

	// Then: it should add Fleet entries
	suite.NoError(err, "Should update hosts file without error")

	content, err := os.ReadFile(hostsFile)
	suite.NoError(err)
	contentStr := string(content)

	suite.Contains(contentStr, "# Fleet Services - START", "Should contain Fleet section start marker")
	suite.Contains(contentStr, "127.0.0.1 web.test", "Should contain web.test mapping")
	suite.Contains(contentStr, "127.0.0.1 api.test", "Should contain api.test mapping")
	suite.Contains(contentStr, "# Fleet Services - END", "Should contain Fleet section end marker")
	suite.Contains(contentStr, "192.168.1.1 router.local", "Should preserve existing entries")
}

func (suite *NginxTestSuite) TestUpdateHostsFileWithDomains_UpdateExistingEntries() {
	// Given: Hosts file with existing Fleet entries
	hostsFile := filepath.Join(suite.tempDir, "hosts")
	existingContent := `127.0.0.1 localhost

# Fleet Services - START
127.0.0.1 old.test
127.0.0.1 legacy.test
# Fleet Services - END

# Other entries
192.168.1.1 router.local`

	err := os.WriteFile(hostsFile, []byte(existingContent), 0644)
	suite.Require().NoError(err)

	// Mock getHostsFilePath
	originalGetHostsFilePath := getHostsFilePath
	getHostsFilePath = func() string { return hostsFile }
	defer func() { getHostsFilePath = originalGetHostsFilePath }()

	config := &Config{
		Services: []Service{
			{
				Name:   "web",
				Domain: "new.test",
				Port:   8080,
			},
		},
	}

	// When: updating hosts file
	err = updateHostsFileWithDomains(config)

	// Then: it should replace old Fleet entries with new ones
	suite.NoError(err)

	content, err := os.ReadFile(hostsFile)
	suite.NoError(err)
	contentStr := string(content)

	suite.Contains(contentStr, "127.0.0.1 new.test", "Should contain new domain")
	suite.NotContains(contentStr, "127.0.0.1 old.test", "Should not contain old domain")
	suite.NotContains(contentStr, "127.0.0.1 legacy.test", "Should not contain legacy domain")
	suite.Contains(contentStr, "192.168.1.1 router.local", "Should preserve non-Fleet entries")
}

func (suite *NginxTestSuite) TestUpdateHostsFileWithDomains_NoDomainsToAdd() {
	// Given: Config with no services needing domains
	hostsFile := filepath.Join(suite.tempDir, "hosts")
	existingContent := `127.0.0.1 localhost`

	err := os.WriteFile(hostsFile, []byte(existingContent), 0644)
	suite.Require().NoError(err)

	// Mock getHostsFilePath
	originalGetHostsFilePath := getHostsFilePath
	getHostsFilePath = func() string { return hostsFile }
	defer func() { getHostsFilePath = originalGetHostsFilePath }()

	config := &Config{
		Services: []Service{
			{
				Name:  "worker",
				Image: "worker:latest",
			},
		},
	}

	// When: updating hosts file
	err = updateHostsFileWithDomains(config)

	// Then: hosts file should remain unchanged
	suite.NoError(err)

	content, err := os.ReadFile(hostsFile)
	suite.NoError(err)
	contentStr := string(content)

	suite.NotContains(contentStr, "# Fleet Services", "Should not add Fleet section when no domains")
}

// Test removeDomainsFromHostsFile
func (suite *NginxTestSuite) TestRemoveDomainsFromHostsFile() {
	// Given: Hosts file with Fleet entries
	hostsFile := filepath.Join(suite.tempDir, "hosts")
	existingContent := `127.0.0.1 localhost

# Fleet Services - START
127.0.0.1 web.test
127.0.0.1 api.test
# Fleet Services - END

192.168.1.1 router.local`

	err := os.WriteFile(hostsFile, []byte(existingContent), 0644)
	suite.Require().NoError(err)

	// Mock getHostsFilePath
	originalGetHostsFilePath := getHostsFilePath
	getHostsFilePath = func() string { return hostsFile }
	defer func() { getHostsFilePath = originalGetHostsFilePath }()

	// When: removing domains from hosts file
	err = removeDomainsFromHostsFile()

	// Then: Fleet section should be removed
	suite.NoError(err)

	content, err := os.ReadFile(hostsFile)
	suite.NoError(err)
	contentStr := string(content)

	suite.NotContains(contentStr, "# Fleet Services", "Fleet section should be removed")
	suite.NotContains(contentStr, "web.test", "web.test should be removed")
	suite.NotContains(contentStr, "api.test", "api.test should be removed")
	suite.Contains(contentStr, "127.0.0.1 localhost", "Should preserve localhost entry")
	suite.Contains(contentStr, "192.168.1.1 router.local", "Should preserve other entries")
}

func (suite *NginxTestSuite) TestRemoveDomainsFromHostsFile_NoFleetSection() {
	// Given: Hosts file without Fleet entries
	hostsFile := filepath.Join(suite.tempDir, "hosts")
	existingContent := `127.0.0.1 localhost
192.168.1.1 router.local`

	err := os.WriteFile(hostsFile, []byte(existingContent), 0644)
	suite.Require().NoError(err)

	// Mock getHostsFilePath
	originalGetHostsFilePath := getHostsFilePath
	getHostsFilePath = func() string { return hostsFile }
	defer func() { getHostsFilePath = originalGetHostsFilePath }()

	// When: removing domains from hosts file
	err = removeDomainsFromHostsFile()

	// Then: hosts file should remain unchanged
	suite.NoError(err)

	content, err := os.ReadFile(hostsFile)
	suite.NoError(err)
	contentStr := string(content)

	suite.Equal(existingContent, contentStr, "Content should remain unchanged")
}

// Test writeNginxConfig
func (suite *NginxTestSuite) TestWriteNginxConfig() {
	// Given: Config with services
	config := &Config{
		Services: []Service{
			{
				Name:   "web",
				Domain: "web.test",
				Port:   8080,
			},
		},
	}

	nginxConfigPath := filepath.Join(suite.tempDir, "nginx.conf")

	// When: writing nginx config
	err := writeNginxConfig(config, nginxConfigPath)

	// Then: config file should be created
	suite.NoError(err)

	// Verify file exists and contains expected content
	content, err := os.ReadFile(nginxConfigPath)
	suite.NoError(err)
	suite.Contains(string(content), "upstream web_backend", "Should contain web upstream")
	suite.Contains(string(content), "server_name web.test", "Should contain web.test server")
}

// Test complex port parsing scenarios
func (suite *NginxTestSuite) TestGenerateNginxConfig_ComplexPortMappings() {
	// Given: Services with various port configurations
	// NOTE: Services need either a Port field or Domain field to trigger nginx proxy generation
	config := &Config{
		Services: []Service{
			{
				Name:   "web1",
				Domain: "web1.test",
				Ports:  []string{"8080:80"},
			},
			{
				Name:   "web2",
				Domain: "web2.test",
				Ports:  []string{"127.0.0.1:8081:80"},
			},
			{
				Name:   "web3",
				Domain: "web3.test",
				Ports:  []string{"8082:80/tcp"},
			},
			{
				Name: "web4",
				Port: 3000,
			},
		},
	}

	// When: generating nginx config
	nginxConf, err := generateNginxConfig(config)

	// Then: all port formats should be parsed correctly
	suite.NoError(err)
	suite.Contains(nginxConf, "server web1:80", "Should parse simple port mapping")
	suite.Contains(nginxConf, "server web2:80", "Should parse port mapping with IP")
	suite.Contains(nginxConf, "server web3:80", "Should parse port mapping with protocol")
	suite.Contains(nginxConf, "server web4:3000", "Should use direct port value")
}

// Test edge cases and error conditions
func (suite *NginxTestSuite) TestUpdateHostsFileWithDomains_FilePermissionError() {
	// Given: Read-only hosts file
	hostsFile := filepath.Join(suite.tempDir, "readonly-hosts")
	err := os.WriteFile(hostsFile, []byte("127.0.0.1 localhost"), 0444)
	suite.Require().NoError(err)

	// Mock getHostsFilePath
	originalGetHostsFilePath := getHostsFilePath
	getHostsFilePath = func() string { return hostsFile }
	defer func() { getHostsFilePath = originalGetHostsFilePath }()

	config := &Config{
		Services: []Service{
			{
				Name:   "web",
				Domain: "web.test",
				Port:   8080,
			},
		},
	}

	// When: updating hosts file
	err = updateHostsFileWithDomains(config)

	// Then: it should return an error
	suite.Error(err, "Should return error when file is read-only")
	// When sudo fails (no password provided in tests), it returns "exit status 1"
	// or when the normal write fails, it should contain permission-related error
	errMsg := err.Error()
	suite.True(strings.Contains(errMsg, "permission denied") || strings.Contains(errMsg, "exit status 1") || strings.Contains(errMsg, "failed to write hosts file"), 
		"Error should indicate permission issue or sudo failure")
}

// Test helper function to verify nginx config syntax
func (suite *NginxTestSuite) TestGenerateNginxConfig_ValidSyntax() {
	// Given: Complex config with multiple services
	config := &Config{
		Services: []Service{
			{
				Name:   "frontend",
				Domain: "app.test",
				Port:   3000,
			},
			{
				Name:   "backend",
				Domain: "api.test",
				Port:   8080,
			},
			{
				Name: "admin",
				Port: 9000,
			},
		},
	}

	// When: generating nginx config
	nginxConf, err := generateNginxConfig(config)

	// Then: config should have valid nginx syntax elements
	suite.NoError(err)

	// Verify essential nginx directives are present
	suite.Contains(nginxConf, "user nginx;", "Should have user directive")
	suite.Contains(nginxConf, "worker_processes auto;", "Should have worker_processes")
	suite.Contains(nginxConf, "events {", "Should have events block")
	suite.Contains(nginxConf, "http {", "Should have http block")

	// Verify upstream blocks
	suite.Contains(nginxConf, "upstream frontend_backend", "Should have frontend upstream")
	suite.Contains(nginxConf, "upstream backend_backend", "Should have backend upstream")
	suite.Contains(nginxConf, "upstream admin_backend", "Should have admin upstream")

	// Verify server blocks
	suite.Contains(nginxConf, "server_name app.test;", "Should have app.test server")
	suite.Contains(nginxConf, "server_name api.test;", "Should have api.test server")
	suite.Contains(nginxConf, "server_name admin.test;", "Should have auto-generated admin.test")

	// Verify proxy settings
	suite.Contains(nginxConf, "proxy_pass http://", "Should have proxy_pass directives")
	suite.Contains(nginxConf, "proxy_set_header", "Should have proxy headers")

	// Verify WebSocket support
	suite.Contains(nginxConf, "proxy_set_header Upgrade", "Should support WebSocket upgrade")
	suite.Contains(nginxConf, "proxy_set_header Connection", "Should support WebSocket connection")

	// Count server blocks - should have default + health + 3 service blocks
	serverCount := strings.Count(nginxConf, "server {")
	suite.Equal(5, serverCount, "Should have 5 server blocks (1 default + 1 health + 3 services)")
}

func TestNginxSuite(t *testing.T) {
	suite.Run(t, new(NginxTestSuite))
}